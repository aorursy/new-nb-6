import numpy as np

import pandas as pd

import itertools



pd.set_option('display.float_format', '{:.10f}'.format)



train = pd.read_csv('../input/train.csv')

cols = ['card_id','merchant_id','month_lag','purchase_amount','purchase_date','authorized_flag']

historical_transactions = pd.read_csv('../input/historical_transactions.csv',usecols=cols).fillna('')

new_merchant_transactions = pd.read_csv('../input/new_merchant_transactions.csv',usecols=cols).fillna('')



historical_transactions['purchase_amount'] = np.round(historical_transactions['purchase_amount'] / 0.00150265118 + 497.06,2)

new_merchant_transactions['purchase_amount'] = np.round(new_merchant_transactions['purchase_amount'] / 0.00150265118 + 497.06,2)

train['target'] = 2**train['target']



#only interested in authorized transactions:

historical_transactions = historical_transactions.loc[historical_transactions['authorized_flag']=='Y'].reset_index(drop=True)
# adding "new merchant" flag for each transaction

first_hist_merchant_transaction = historical_transactions.groupby(['card_id','merchant_id'])['month_lag'].min().reset_index(name='month_lag')

first_new_merchant_transaction = new_merchant_transactions.groupby(['card_id','merchant_id'])['month_lag'].min().reset_index(name='month_lag')

first_hist_merchant_transaction['new'] = 1

first_new_merchant_transaction['new'] = 1

historical_transactions = historical_transactions.merge(first_hist_merchant_transaction, on = ['card_id','merchant_id','month_lag'], how = 'left')

new_merchant_transactions = new_merchant_transactions.merge(first_new_merchant_transaction, on = ['card_id','merchant_id','month_lag'], how = 'left')

historical_transactions.loc[pd.isnull(historical_transactions['new']),'new'] = 0

new_merchant_transactions.loc[pd.isnull(new_merchant_transactions['new']),'new'] = 0
dist_hist = historical_transactions.groupby(['new','month_lag'])['purchase_amount'].sum().reset_index(name='total_purchase_amount')

dist_new = new_merchant_transactions.groupby(['new','month_lag'])['purchase_amount'].sum().reset_index(name='total_purchase_amount')

dist = pd.concat([dist_hist, dist_new]).reset_index(drop=True)
dist.pivot('month_lag','new','total_purchase_amount')
historical_transactions = historical_transactions.sort_values(['card_id','purchase_date']).reset_index(drop=True)

historical_transactions = historical_transactions.groupby(['card_id','merchant_id']).tail(1).reset_index(drop=True)
# month lags

amtmth = historical_transactions[['card_id', 'purchase_amount','month_lag']].groupby(['card_id', 'purchase_amount'])['month_lag'].max().reset_index()

amtmth = amtmth.groupby('card_id').apply(lambda x: dict(zip(x['purchase_amount'],x['month_lag']))).reset_index(name = 'dict')

amtmth = dict(zip(amtmth['card_id'],amtmth['dict']))



# purchase amounts 

amtpurch = historical_transactions.groupby('card_id')['purchase_amount'].apply(list).reset_index(name='amounts')

amtpurch = dict(zip(amtpurch['card_id'],amtpurch['amounts']))



# targets

target = dict(zip(train['card_id'],train['target']))
def get_future_amount(trainnum, max_combinations = 100000):

    "max_combinations: number of possible combinations to explore (less - faster, more - slower)"



    card_id = train['card_id'][trainnum]

    k = 1

    

    #collection of possible solutions

    comb = {}

    comb2 = {}

    

    for i in range(1, 10):

        # we want to fully exhaust solutions of length 1 and 2

        # if we found something, do not go into deeper permutation levels

        # 2 is arbitrary and can be tuned. However, starting from 3 performance drops significantly

        if (len(comb) > 0) and (i > 2):

            break

        # need to set hard limit or else we are doomed :)

        if k == max_combinations:

            break    

        for subset in itertools.combinations(amtpurch[card_id], i):

            k+=1

            if k == max_combinations:

                break

            amt = np.round(np.sum(subset), 2)

            amt_month = np.mean([amtmth[card_id][x] for x in subset])

            amt_target = amt * target[card_id] * 2 #this is the loyalty formula as discussed earlier!!!

            # let's see if it rounds up nicely...

            if np.round(amt_target, 2) == np.round(amt_target, 5):      

                comb[tuple(sorted(subset))] = np.round(amt_target, 2), amt_month

            # backup plan with higher error tolerance...

            if np.round(amt_target, 2) == np.round(amt_target, 4):      

                comb2[tuple(sorted(subset))] = np.round(amt_target, 2), amt_month

    

    # if no higher precision combinations found, use combinations with lower precision

    if len(comb) == 0:

        comb = comb2

    

    best = np.nan

    if len(comb) > 0:       

        q = [z[0] for z in comb.values()]

        m = [z[1] for z in comb.values()]

        best = q[np.argmax(m)]

    return comb, best, target[card_id]
get_future_amount(0)
historical_transactions[historical_transactions['card_id']==train['card_id'][0]]
out = []



for i in range(100):

    out.append(get_future_amount(i)[1])
train['loyal_spending'] = np.nan

train['loyal_spending'][0:100] = out

train.head(100)